# go-musthave-metrics-tpl

Шаблон репозитория для трека «Сервер сбора метрик и алертинга».

## Начало работы

1. Склонируйте репозиторий в любую подходящую директорию на вашем компьютере.
2. В корне репозитория выполните команду `go mod init <name>` (где `<name>` — адрес вашего репозитория на GitHub без префикса `https://`) для создания модуля.

## Обновление шаблона

Чтобы иметь возможность получать обновления автотестов и других частей шаблона, выполните команду:

```
git remote add -m main template https://github.com/Yandex-Practicum/go-musthave-metrics-tpl.git
```

Для обновления кода автотестов выполните команду:

```
git fetch template && git checkout template/main .github
```

Затем добавьте полученные изменения в свой репозиторий.

## Запуск автотестов

Для успешного запуска автотестов называйте ветки `iter<number>`, где `<number>` — порядковый номер инкремента. Например, в ветке с названием `iter4` запустятся автотесты для инкрементов с первого по четвёртый.

При мёрже ветки с инкрементом в основную ветку `main` будут запускаться все автотесты.

Подробнее про локальный и автоматический запуск читайте в [README автотестов](https://github.com/Yandex-Practicum/go-autotests).

# Сервис сборка метрик и алертинга

## Итерация #9

Доработайте код сервера, чтобы он мог с заданной периодичностью сохранять текущие значения метрик на диск в указанный файл, а на старте — опционально загружать сохранённые ранее значения. При штатном завершении сервера все накопленные данные должны сохраняться.

Сервер должен принимать соответствующие параметры конфигурации через флаги и переменные окружения:
* Флаг -i, переменная окружения STORE_INTERVAL — интервал времени в секундах, по истечении которого текущие показания сервера сохраняются на диск (по умолчанию 300 секунд, значение 0 делает запись синхронной).
* Флаг -f, переменная окружения FILE_STORAGE_PATH — полное имя файла, куда сохраняются текущие значения (по умолчанию /tmp/metrics-db.json, пустое значение отключает функцию записи на диск).
* Флаг -r, переменная окружения RESTORE — булево значение (true/false), определяющее, загружать или нет ранее сохранённые значения из указанного файла при старте сервера (по умолчанию true).

Приоритет параметров сервера должен быть таким:
* Если указана переменная окружения, то используется она.
* Если нет переменной окружения, но есть флаг, то используется он.
* Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

## Итерация #10

Сервер:
* Добавьте функциональность подключения к базе данных. В качестве СУБД используйте PostgreSQL не ниже 10 версии.
* Добавьте в сервер хендлер GET /ping, который при запросе проверяет соединение с базой данных. При успешной проверке хендлер должен вернуть HTTP-статус 200 OK, при неуспешной — 500 Internal Server Error.

Строка с адресом подключения к БД должна получаться из переменной окружения DATABASE_DSN или флага командной строки -d.

Для работы с БД используйте один из следующих пакетов:
* database/sql,
* github.com/jackc/pgx,
* github.com/lib/pq,
* github.com/jmoiron/sqlx.

## Итерация #11

Перепишите сервер для сбора метрик таким образом, чтобы СУБД PostgreSQL стала хранилищем метрик вместо текущей реализации.

Сервису нужно самостоятельно создать все необходимые таблицы в базе данных. Схема и формат хранения остаются на ваше усмотрение.

Для хранения значений gauge рекомендуется использовать тип double precision.

При отсутствии переменной окружения DATABASE_DSN или флага командной строки -d или при их пустых значениях вернитесь последовательно к:
* хранению метрик в файле при наличии соответствующей переменной окружения или флага командной строки;
* хранению метрик в памяти.

## Итерация #12

Сервер:
* Добавьте новый хендлер POST /updates/, принимающий в теле запроса множество метрик в формате: []Metrics (списка метрик).

Агент:
* Научите агент работать с использованием нового API (отправлять метрики батчами).

Стоит помнить, что:
* нужно соблюдать обратную совместимость;
* отправлять пустые батчи не нужно;
* вы умеете сжимать контент по алгоритму gzip;
* изменение в базе можно выполнять в рамках одной транзакции или одного запроса;
* необходимо избегать формирования условий для возникновения состояния гонки (race condition).

## Итерация #13

Добавьте обработку retriable-ошибок.

Retriable-ошибки — это ошибки, которые могут быть исправлены повторной попыткой выполнения операции. Это бывает полезно для программ, которые работают с сетью или файловой системой, где возможны временные проблемы связи или доступа к данным. Ошибки могут быть вызваны различными причинами, такими как перегрузка сервера, недоступность сети или ошибки в коде программы.

Примеры retriable-ошибок:
* Ошибка связи с сервером при отправке запроса.
* Ошибка чтения данных из сети или БД из-за проблем соединения.
* Ошибка доступа к файлу, который был заблокирован другим процессом.

Сценарии возможных ошибок:
* Агент не сумел с первой попытки выгрузить данные на сервер из-за временной невозможности установить соединение с сервером.
* При обращении к PostgreSQL cервер получил ошибку транспорта (из категории Class 08 — Connection Exception).

Стратегия реализации:
* Количество повторов должно быть ограничено тремя дополнительными попытками.
* Интервалы между повторами должны увеличиваться: 1s, 3s, 5s.
* Чтобы определить тип ошибки PostgreSQL, с которой завершился запрос, можно воспользоваться библиотекой `github.com/jackc/pgerrcode`, в частности `pgerrcode.UniqueViolation`.

## Итерация #14

Реализуйте механизм подписи передаваемых данных по алгоритму SHA256. Для этого посчитайте `hash` от всего тела запроса и разместите его в HTTP-заголовке `HashSHA256`.

Хеш нужно считать от строки с учётом ключа, который передан агенту/серверу на старте: `hash(value, key)`.

Агент:
* Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
* При наличии ключа агент должен вычислять хеш и передавать в HTTP-заголовке запроса с именем `HashSHA256`.

Сервер:
* Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
* При наличии ключа во время обработки запроса сервер должен проверять соответствие полученного и вычисленного хеша.
* При несовпадении сервер должен отбрасывать полученные данные и возвращать `http.StatusBadRequest`.
* При наличии ключа на этапе формирования ответа сервер должен вычислять хеш и передавать его в HTTP-заголовке ответа с именем `HashSHA256`.
