# Сервис сборка метрик и алертинга

## Итерация #1

Разработайте сервер для сбора рантайм-метрик, который будет собирать репорты от агентов по протоколу HTTP. Агент вам предстоит реализовать в следующем инкременте — в качестве источника метрик вы будете использовать пакет `runtime`.

Сервер должен быть доступен по адресу `http://localhost:8080`, а также:
* Принимать и хранить произвольные метрики двух типов:
** Тип `gauge`, `float64` — новое значение должно замещать предыдущее.
** Тип `counter`, `int64` — новое значение должно добавляться к предыдущему, если какое-то значение уже было известно серверу.
* Принимать метрики по протоколу HTTP методом `POST`.
* Принимать данные в формате `http://<АДРЕС_СЕРВЕРА>/update/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>/<ЗНАЧЕНИЕ_МЕТРИКИ>`, `Content-Type: text/plain`.
* При успешном приёме возвращать `http.StatusOK`.
* При попытке передать запрос без имени метрики возвращать `http.StatusNotFound`.
* При попытке передать запрос с некорректным типом метрики или значением возвращать `http.StatusBadRequest`.

Редиректы не поддерживаются.

Для хранения метрик объявите тип `MemStorage`. Рекомендуем использовать тип `struct` с полем-коллекцией внутри (`slice` или `map`). В будущем это позволит добавлять к объекту хранилища новые поля, например логер или мьютекс, чтобы можно было использовать их в методах. Опишите интерфейс для взаимодействия с этим хранилищем.

Пример запроса к серверу:
```
POST /update/counter/someMetric/527 HTTP/1.1
Host: localhost:8080
Content-Length: 0
Content-Type: text/plain
```

Пример ответа от сервера:
```
HTTP/1.1 200 OK
Date: Tue, 21 Feb 2023 02:51:35 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
```

## Итерация #2

Разработайте агент (HTTP-клиент) для сбора рантайм-метрик и их последующей отправки на сервер по протоколу HTTP.

Агент должен собирать метрики двух типов:
* Тип `gauge`, `float64`.
* Тип `counter`, `int64`.

В качестве источника метрик используйте пакет `runtime`.

Нужно собирать следующие метрики типа `gauge`:
* `Alloc`
* `BuckHashSys`
* `Frees`
* `GCCPUFraction`
* `GCSys`
* `HeapAlloc`
* `HeapIdle`
* `HeapInuse`
* `HeapObjects`
* `HeapReleased`
* `HeapSys`
* `LastGC`
* `Lookups`
* `MCacheInuse`
* `MCacheSys`
* `MSpanInuse`
* `MSpanSys`
* `Mallocs`
* `NextGC`
* `NumForcedGC`
* `NumGC`
* `OtherSys`
* `PauseTotalNs`
* `StackInuse`
* `StackSys`
* `Sys`
* `TotalAlloc`

К метрикам пакета `runtime` добавьте ещё две:
* `PollCount` (тип `counter`) — счётчик, увеличивающийся на 1 при каждом обновлении метрики из пакета `runtime` (на каждый `pollInterval` — см. ниже).
* `RandomValue` (тип `gauge`) — обновляемое произвольное значение.

По умолчанию приложение должно:
* Обновлять метрики из пакета `runtime` с заданной частотой: `pollInterval` — 2 секунды.
* Отправлять метрики на сервер с заданной частотой: `reportInterval` — 10 секунд.

Чтобы приостанавливать работу функции на заданное время, используйте вызов `time.Sleep(n * time.Second)`. Подробнее о пакете `time` и его возможностях вы узнаете в третьем спринте.

Метрики нужно отправлять по протоколу HTTP методом `POST`:
* Формат данных — `http://<АДРЕС_СЕРВЕРА>/update/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>/<ЗНАЧЕНИЕ_МЕТРИКИ>`.
* Адрес сервера — `http://localhost:8080`.
* Заголовок — `Content-Type: text/plain`.

Пример запроса к серверу:
```
POST /update/counter/someMetric/527 HTTP/1.1
Host: localhost:8080
Content-Length: 0
Content-Type: text/plain
```

Пример ответа от сервера:
```
HTTP/1.1 200 OK
Date: Tue, 21 Feb 2023 02:51:35 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
```

## Итерация #3

Вы написали приложение с помощью пакета стандартной библиотеки `net/http`. Используя любой внешний пакет (роутер или фреймворк), совместимый с `net/http`, перепишите ваш код.

Доработайте сервер так, чтобы в ответ на запрос `GET http://<АДРЕС_СЕРВЕРА>/value/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>` он возвращал текущее значение метрики в текстовом виде со статусом `http.StatusOK`.

При попытке запроса неизвестной метрики сервер должен возвращать `http.StatusNotFound`.

По запросу `GET http://<АДРЕС_СЕРВЕРА>/` сервер должен отдавать HTML-страницу со списком имён и значений всех известных ему на текущий момент метрик.

Хендлеры должны взаимодействовать с экземпляром `MemStorage` при помощи соответствующих интерфейсных методов.

## Итерация #4

Доработайте код, чтобы он умел принимать аргументы с использованием флагов.

Аргументы сервера:
* Флаг `-a=<ЗНАЧЕНИЕ>` отвечает за адрес эндпоинта HTTP-сервера (по умолчанию `localhost:8080`).

Аргументы агента:
* Флаг `-a=<ЗНАЧЕНИЕ>` отвечает за адрес эндпоинта HTTP-сервера (по умолчанию `localhost:8080`).
* Флаг `-r=<ЗНАЧЕНИЕ>` позволяет переопределять `reportInterval` — частоту отправки метрик на сервер (по умолчанию 10 секунд).
* Флаг `-p=<ЗНАЧЕНИЕ>` позволяет переопределять `pollInterval` — частоту опроса метрик из пакета `runtime` (по умолчанию 2 секунды).

При попытке передать приложению незвестные флаги оно должно завершаться с сообщением о соответствующей ошибке.

Значения интервалов времени должны задаваться в секундах.

Во всех случаях должны присутствовать значения по умолчанию.

## Итерация #5

Доработайте агент, чтобы он мог изменять свои параметры запуска по умолчанию через переменные окружения:
* `ADDRESS` отвечает за адрес эндпоинта HTTP-сервера.
* `REPORT_INTERVAL` позволяет переопределять `reportInterval`.
* `POLL_INTERVAL` позволяет переопределять `pollInterval`.

Значения интервалов времени должны задаваться в секундах.

Доработайте сервер, чтобы он мог изменять свои параметры запуска по умолчанию через переменные окружения:
* `ADDRESS` отвечает за адрес эндпоинта HTTP-сервера.

Приоритет параметров должен быть таким:
* Если указана переменная окружения, то используется она.
* Если нет переменной окружения, но есть аргумент командной строки (флаг), то используется он.
* Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

## Итерация #6

Реализуйте логирование сведений о запросах и ответах на сервере для всех эндпоинтов, которые у вас уже есть.
* Сведения о запросах должны содержать URI, метод запроса и время, затраченное на его выполнение.
* Сведения об ответах должны содержать код статуса и размер содержимого ответа.

Эту функциональность нужно реализовать через `middlewar`e. Используйте один из сторонних пакетов для логирования:
* github.com/rs/zerolog,
* go.uber.org/zap,
* github.com/sirupsen/logrus.

Все сообщения логера должны быть на уровне `Info`.

## Итерация #7

Дополните API сервера, чтобы позволить ему принимать метрики в формате JSON.

При реализации задействуйте одну из распространённых библиотек:
* `encoding/json`,
* `github.com/mailru/easyjson`,
* `github.com/pquerna/ffjson`.

Обмен с сервером организуйте с использованием следующей структуры:
```
  type Metrics struct {
     ID    string   `json:"id"`              // имя метрики
     MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
     Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
     Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
  }
```

Для передачи метрик на сервер используйте `Content-Type: application/json`. В теле запроса должен быть описанный выше JSON. Передавать метрики нужно через `POST update/`. В теле ответа отправляйте JSON той же структуры с актуальным (изменённым) значением `Value`.

Для получения метрик с сервера также используйте `Content-Type: application/json`. В теле запроса должен быть описанный выше JSON с заполненными полями `ID` и `MType`. Запрашивать нужно через `POST value/`. В теле ответа должен приходить такой же JSON, но с уже заполненными значениями метрик.

Переведите агент на новый API.

Автотесты проверяют, что агент экспортирует и обновляет на сервере метрики, описанные в первых инкрементах.

## Итерация #8

Добавьте поддержку gzip в код сервера и агента. Научите:
* Агент передавать данные в формате gzip.
* Сервер опционально принимать запросы в сжатом формате (при наличии соответствующего HTTP-заголовка `Content-Encoding`).
* Отдавать сжатый ответ клиенту, который поддерживает обработку сжатых ответов (с HTTP-заголовком `Accept-Encoding`).

Функция сжатия должна работать для контента с типами `application/json` и `text/html`.

Вспомните `middleware` из урока про HTTP-сервер, это может вам помочь.

## Итерация #9

Доработайте код сервера, чтобы он мог с заданной периодичностью сохранять текущие значения метрик на диск в указанный файл, а на старте — опционально загружать сохранённые ранее значения. При штатном завершении сервера все накопленные данные должны сохраняться.

Сервер должен принимать соответствующие параметры конфигурации через флаги и переменные окружения:
* Флаг `-i`, переменная окружения `STORE_INTERVAL` — интервал времени в секундах, по истечении которого текущие показания сервера сохраняются на диск (по умолчанию 300 секунд, значение `0` делает запись синхронной).
* Флаг `-f`, переменная окружения `FILE_STORAGE_PATH` — полное имя файла, куда сохраняются текущие значения (по умолчанию `/tmp/metrics-db.json`, пустое значение отключает функцию записи на диск).
* Флаг `-r`, переменная окружения `RESTORE` — булево значение (`true/false`), определяющее, загружать или нет ранее сохранённые значения из указанного файла при старте сервера (по умолчанию `true`).

Приоритет параметров сервера должен быть таким:
* Если указана переменная окружения, то используется она.
* Если нет переменной окружения, но есть флаг, то используется он.
* Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

## Итерация #10

Сервер:
* Добавьте функциональность подключения к базе данных. В качестве СУБД используйте PostgreSQL не ниже 10 версии.
* Добавьте в сервер хендлер `GET /ping`, который при запросе проверяет соединение с базой данных. При успешной проверке хендлер должен вернуть HTTP-статус `200 OK`, при неуспешной — `500 Internal Server Error`.

Строка с адресом подключения к БД должна получаться из переменной окружения `DATABASE_DSN` или флага командной строки `-d`.

Для работы с БД используйте один из следующих пакетов:
* `database/sql`,
* `github.com/jackc/pgx`,
* `github.com/lib/pq`,
* `github.com/jmoiron/sqlx`.

## Итерация #11

Перепишите сервер для сбора метрик таким образом, чтобы СУБД PostgreSQL стала хранилищем метрик вместо текущей реализации.

Сервису нужно самостоятельно создать все необходимые таблицы в базе данных. Схема и формат хранения остаются на ваше усмотрение.

Для хранения значений `gauge` рекомендуется использовать тип `double precision`.

При отсутствии переменной окружения `DATABASE_DSN` или флага командной строки `-d` или при их пустых значениях вернитесь последовательно к:
* хранению метрик в файле при наличии соответствующей переменной окружения или флага командной строки;
* хранению метрик в памяти.

## Итерация #12

Сервер:
* Добавьте новый хендлер `POST /updates/`, принимающий в теле запроса множество метрик в формате: `[]Metrics` (списка метрик).

Агент:
* Научите агент работать с использованием нового API (отправлять метрики батчами).

Стоит помнить, что:
* нужно соблюдать обратную совместимость;
* отправлять пустые батчи не нужно;
* вы умеете сжимать контент по алгоритму gzip;
* изменение в базе можно выполнять в рамках одной транзакции или одного запроса;
* необходимо избегать формирования условий для возникновения состояния гонки (race condition).

## Итерация #13

Добавьте обработку retriable-ошибок.

Retriable-ошибки — это ошибки, которые могут быть исправлены повторной попыткой выполнения операции. Это бывает полезно для программ, которые работают с сетью или файловой системой, где возможны временные проблемы связи или доступа к данным. Ошибки могут быть вызваны различными причинами, такими как перегрузка сервера, недоступность сети или ошибки в коде программы.

Примеры retriable-ошибок:
* Ошибка связи с сервером при отправке запроса.
* Ошибка чтения данных из сети или БД из-за проблем соединения.
* Ошибка доступа к файлу, который был заблокирован другим процессом.

Сценарии возможных ошибок:
* Агент не сумел с первой попытки выгрузить данные на сервер из-за временной невозможности установить соединение с сервером.
* При обращении к PostgreSQL cервер получил ошибку транспорта (из категории Class 08 — Connection Exception).

Стратегия реализации:
* Количество повторов должно быть ограничено тремя дополнительными попытками.
* Интервалы между повторами должны увеличиваться: 1s, 3s, 5s.
* Чтобы определить тип ошибки PostgreSQL, с которой завершился запрос, можно воспользоваться библиотекой `github.com/jackc/pgerrcode`, в частности `pgerrcode.UniqueViolation`.

## Итерация #14

Реализуйте механизм подписи передаваемых данных по алгоритму SHA256. Для этого посчитайте `hash` от всего тела запроса и разместите его в HTTP-заголовке `HashSHA256`.

Хеш нужно считать от строки с учётом ключа, который передан агенту/серверу на старте: `hash(value, key)`.

Агент:
* Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
* При наличии ключа агент должен вычислять хеш и передавать в HTTP-заголовке запроса с именем `HashSHA256`.

Сервер:
* Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
* При наличии ключа во время обработки запроса сервер должен проверять соответствие полученного и вычисленного хеша.
* При несовпадении сервер должен отбрасывать полученные данные и возвращать `http.StatusBadRequest`.
* При наличии ключа на этапе формирования ответа сервер должен вычислять хеш и передавать его в HTTP-заголовке ответа с именем `HashSHA256`.

## Итерация 15

Перепланируйте архитектуру агента таким образом, чтобы сбор метрик (опрос runtime) и их отправка осуществлялись в разных горутинах. При этом количество одновременно исходящих запросов на сервер нужно ограничивать «сверху».

Соответствующее значение должно задаваться аргументами:
* Через флаг `-l=<ЗНАЧЕНИЕ>` и переменную окружения `RATE_LIMIT`.

Совет:
* Используйте паттерн worker pool.

Добавьте ещё одну горутину, которая будет использовать пакет [gopsutil](https://github.com/shirou/gopsutil) и собирать дополнительные метрики типа `gauge`:
* `TotalMemory`,
* `FreeMemory`,
* `CPUutilization1` (точное количество — по числу CPU, определяемому во время исполнения).

## Инкремент 16

Добавьте в свой проект бенчмарки, измеряющие скорость выполнения важнейших компонентов вашей системы.

Проведите анализ использования памяти вашим проектом, определите и исправьте неэффективные части кода по следующему алгоритму:
1. Используя профилировщик `pprof`, сохраните профиль потребления памяти вашим проектом в директорию `profiles` с именем `base.pprof`.
2. Изучите полученный профиль, определите и исправьте неэффективные части вашего кода.
3. Повторите пункт 1 и сохраните новый профиль потребления памяти в директорию `profiles` с именем `result.pprof`.

Проверьте результат внесённых изменений командой:
```
pprof -top -diff_base=profiles/base.pprof profiles/result.pprof
```

В случае успешной оптимизации вы увидите в выводе командной строки результаты с отрицательными значениями, означающими уменьшение потребления ресурсов.

**Внимание**: к концу текущего спринта покрытие вашего кода тестами должно быть не менее 40%.

## Инкремент 17

Отформатируйте свой проект с помощью `gofmt` или `goimports`. Убедитесь, что все файлы проекта прошли форматирование.

**Внимание**: к концу текущего спринта покрытие вашего кода тестами должно быть не менее 40%.

## Инкремент 18

Добавьте к основным экспортированным методам и переменным (хендлерам, публичным структурам и интерфейсам) в вашем проекте документацию в формате `godoc`

Добавьте примеры работы с эндпоинтами практического трека в формате `example_test.go`.

Покрытие вашего кода тестами на данный момент должно быть не менее 40%.

Для проверки покрытия кода можно воспользоваться правилом `cover` из `Makefile`

## Инкремент 19

Создайте свой `multichecker`, состоящий из:
* стандартных статических анализаторов пакета `golang.org/x/tools/go/analysis/passes`;
* всех анализаторов класса `SA` пакета `staticcheck.io`;
* не менее одного анализатора остальных классов пакета `staticcheck.io`;
* двух или более любых публичных анализаторов на ваш выбор.

Напишите и добавьте в `multichecker` собственный анализатор, запрещающий использовать прямой вызов `os.Exit` в функции `main` пакета `main`. При необходимости перепишите код своего проекта так, чтобы он удовлетворял данному анализатору.

Поместите анализатор в директорию `cmd/staticlint` вашего проекта. Добавьте документацию в формате `godoc`, подробно опишите в ней механизм запуска `multichecker`, а также каждый анализатор и его назначение.

Исходный код вашего проекта должен проходить статический анализ созданного `multichecker`.

Покрытие вашего кода тестами к концу спринта должно быть не менее 55%.

## Инкремент 20

Добавьте в пакет `cmd/server` и `cmd/agent` глобальные переменные:
* `var buildVersion string`,
* `var buildDate string`,
* `var buildCommit string`.

При старте приложения выводите в stdout сообщение в следующем формате:
```
Build version: <buildVersion> (или "N/A" при отсутствии значения)
Build date: <buildDate> (или "N/A" при отсутствии значения)
Build commit: <buildCommit> (или "N/A" при отсутствии значения)
```

Покрытие вашего кода тестами на данный момент должно быть не менее 55%.

## Инкремент 21

Добавьте в агент и сервер поддержку асимметричного шифрования.
* Для агента: с помощью флага `-crypto-key` или переменной окружения `CRYPTO_KEY` передайте путь до файла с публичным ключом.
* Для сервера: с помощью флага `-crypto-key` или переменной окружения `CRYPTO_KEY` передайте путь до файла с приватным ключом.

Шифруйте сообщения от агента к серверу с помощью ключей.

## Инкремент 22

Добавьте возможность конфигурации сервера и агента с помощью файла в формате JSON. Нужно поддержать все действующие опции приложения.
Имя файла конфигурации должно задаваться через флаг `-c`/`-config` или переменную окружения `CONFIG`.
Значения из файла конфигурации должны иметь меньший приоритет, чем флаги или переменные окружения.

Формат файла для сервера:
```
{
    "address": "localhost:8080", // аналог переменной окружения ADDRESS или флага -a
    "restore": true, // аналог переменной окружения RESTORE или флага -r
    "store_interval": "1s", // аналог переменной окружения STORE_INTERVAL или флага -i
    "file_storage_path": "/path/to/file.db", // аналог переменной окружения FILE_STORAGE_PATH или -f
    "database_dsn": "", // аналог переменной окружения DATABASE_DSN или флага -d
    "crypto_key": "/path/to/key.pem" // аналог переменной окружения CRYPTO_KEY или флага -crypto-key
}
```

Формат файла для агента:
```
{
    "address": "localhost:8080", // аналог переменной окружения ADDRESS или флага -a
    "report_interval": "1s", // аналог переменной окружения REPORT_INTERVAL или флага -r
    "poll_interval": "1s", // аналог переменной окружения POLL_INTERVAL или флага -p
    "crypto_key": "/path/to/key.pem" // аналог переменной окружения CRYPTO_KEY или флага -crypto-key
}
```

## Инкремент 23

Агент и сервер должны штатно завершаться по сигналам: `syscall.SIGTERM`, `syscall.SIGINT`, `syscall.SIGQUIT`.

Данные, которые находятся в процессе обработки на момент получения сигнала, должны быть успешно переданы агентом на сервер, а сервер должен успешно сохранить все несохранённые данные.

## Инкремент 24

Добавьте в конфигурационный JSON-файл сервера поле `trusted_subnet` (тип `string`, переменная окружения `TRUSTED_SUBNET`, флаг `-t`), в которое можно передать строковое представление бесклассовой адресации (CIDR).

Добавьте в запрос агента заголовок `X-Real-IP`, в котором должен содержаться IP-адрес хоста агента.

При отправке метрик агентом серверу нужно проверять, что переданный в заголовке запроса `X-Real-IP` IP-адрес агента входит в доверенную подсеть, в противном случае возвращать статус ответа `403 Forbidden`.

При пустом значении переменной `trusted_subnet` метрики должны обрабатываться сервером без дополнительных ограничений.

## Инкремент 25

Добавьте возможность обмена данными между сервером и агентом по протоколу gRPC. Поддержите все возможности конфигурации gRPC-сервера и агента аналогично конфигурациям HTTP-сервера.
